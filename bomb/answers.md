1. 调试：

```bash
gdb bomb
```

在 gdb 中调试；同时可以在 gdb 中查看 asm 汇编和 regs 寄存器状态，使用：

```bash
layout asm
layout regs
```

就可以在 gdb 上面实时显示

防止炸弹爆炸：

```gdb
break explode_bomb
```

然后在 phase 1 的入口处打一个断点，然后 `run` 就会运行到这里停下：


2. pahse 1
```bash
break phase_1
```

观察到

```asm
mov $0x402400,%esi
call 0x401388
```

也就是在调用 `string_not_equal` 这个函数之前，先把 `0x402400` 内存地址中的东西放到了 `esi` 寄存器中；而：
- `esi` 寄存器是 `rsi` 寄存器的低 32 位；
- 在调用规定中，
    - **第一个参数**必须放到 `rdi` 中
    - **第二个参数**必须放到 `rsi` 中
    - **第三个参数**必须放到 `rdx` 中
    而第一个参数是用户的输入；

使用 `x/s 0x402400` 查看内容如下：

> Border relations with Canada have never been better.

3. 
![alt text](./figures/image.png)

- 注意到 `read_six_numbers` 这个函数，那么上面的操作就相当于在栈上为其开辟相应的存储空间
- `(%rsp)` 相当于取出栈顶的数字，也就是输入数组中的第一个数字； `cmpl $0x1,(%rsp)` 的意思是做减法运算： `(%rsp) - 1` ，如果结果为 0 （即两个数相等），就把零标志位（ZF）设置为1； `je` 看到 1 就跳转到目标地址 `0x400f30` ，否则顺序执行，炸弹爆炸；

- `lea` ：load effective address，加载有效地址
- `0x400f40` 的指令是： `lea 0x4(%rsp),%rbx` ，就是把 `rbx` 指向栈顶往上偏移4个字节（第一个元素）
- 跳到 `0x400f17` 后， `mov -0x4(%rbx),%eax` 的意思是把 `rbx` 前面一个元素给 `eax` ；
- 然后 `add %eax,%eax` 相当于把 `rbx` 前面一个元素翻倍；
- 然后 `cmp %eax,(%rbx)` 相当于在比较 `rbx` 跟前面一个元素的两倍，如果相等的话跳转到 `0x400f25` ，否则继续往下执行，炸弹爆炸；
- `0x400f25` 处是把 `rbx` 指针继续往后移动（在不越界的情况下）；
- 所以，上面所有的事情就是在说：输入6 个数字，先看第一位是不是1，如果是的话，要求后面每个数字都是前面数字的两倍；

> 1 2 4 8 16 32

4. 
- **关键：**发现上来先调用了 `sscanf` 函数，那么很自然查看 `$0x4025cf` 里面的内容，发现是 `%d %d` ，说明这里需要输入俩整数！
- 在 `call <sscanf>` 后， `%eax` 存的是 “读到了几个数字”
- 代码紧接着用 `cmp $0x1, %eax` 检查是否大于1
- 接着判断输入是否大于等于1（是否输入有效数字），如果啥都没输入就爆炸；
- 如果输入有效数字会跳转到 `cmpl $0x7, 0x8(%rsp)` 这里；这里的意思是如果输入的第一个有效数字（注意前俩是 `%d`）大于7，那么就跳转到 explode；
- **关键：** `jmp *0x402470(,%rax,8)` 实际上是 `switch` 的汇编形式；这里是根据输入的第一个数字来跳转到对应的位置；
    
    所以要查看对应的跳转表，搞清楚是如何跳转的；使用

    ```bash
    x/8gx 0x402470
    ```

    查看跳转表如下：

    ![alt text](./figures/jump_table.png)

    从左上到右下依次是 0 1 2 3 ...

- `jmp` 下面这一堆就都是跳转表，在比较输入的第二个数字和跳转的这里的数字大小，如果相等就进入 `0x400fbe`，相等的话就通过；
- 所以正确答案：
    - 0 207
    - 1 311
    - 2 707
    - 3 256
    - 4 389
    - 5 206
    - 6 682
    - 7 327

5. 